"""
This script provides an example of using the `Send` API in LangGraph for map-reduce operations.

This advanced script demonstrates a map-reduce pattern where a list of subjects is generated,
and then a separate node is dynamically invoked for each subject to generate a joke in parallel.
Finally, a single node selects the best joke from the collected results.

Key Concepts:
- Map-Reduce Pattern: A common pattern where an operation is applied to multiple items in parallel (map)
  and the results are then aggregated (reduce).
- Dynamic Graph Execution: The exact number of parallel branches is not known at compile time but is
  determined dynamically based on the output of a previous node.
- `Send` API: Used in conditional edges to dynamically dispatch tasks to other nodes with specific state
  inputs, enabling the map part of the pattern.
- State Management: The script uses two different state objects: `OverallState` for the main graph and
  `JokeState` for the dynamically called joke generation nodes.

Workflow:
1. **Generate Topics**: A node generates a list of subjects (e.g., "lions", "elephants").
2. **Conditional Branching with `Send`**: A conditional edge function iterates through the subjects and returns a
   list of `Send` objects. Each `Send` object targets the `generate_joke` node with a specific subject.
3. **Generate Jokes (Map)**: The `generate_joke` node is invoked in parallel for each subject, each with its own
   `JokeState`.
4. **Aggregate Jokes (Reduce)**: The results from the `generate_joke` nodes are collected back into the
   `OverallState`'s `jokes` list. The `operator.add` annotation on the `jokes` field ensures that the
   jokes from different branches are appended together.
5. **Select Best Joke**: A final node processes the list of jokes and selects the best one.

To run this script:
```bash
python langgraph_mastery/03_advanced/08_map_reduce_send_api.py
```
"""

import operator
from typing import Annotated
from typing_extensions import TypedDict

from langgraph.graph import END, StateGraph, START
from langgraph.types import Send

# This will be the overall state of the main graph.
# It will contain a topic (which we expect the user to provide)
# and then will generate a list of subjects, and then a joke for
# each subject
class OverallState(TypedDict):
    """The overall state of the main graph."""

    topic: str
    subjects: list
    # Notice here we use the operator.add
    # This is because we want to combine all the jokes we generate
    # from individual nodes back into one list - this is essentially
    # the "reduce" part
    jokes: Annotated[list, operator.add]
    best_selected_joke: str


# This will be the state of the node that we will "map" all
# subjects to in order to generate a joke
class JokeState(TypedDict):
    """The state for the joke generation node."""

    subject: str


# This is the function we will use to generate the subjects of the jokes.
# In general the length of the list generated by this node could vary each run.
def generate_topics(state: OverallState):
    """Generates a list of subjects based on the initial topic."""
    print("---GENERATE TOPICS---")
    # Simulate a LLM.
    return {"subjects": ["lions", "elephants", "penguins"]}


# Here we generate a joke, given a subject
def generate_joke(state: JokeState):
    """Generates a joke for a given subject."""
    print(f"---GENERATE JOKE FOR: {state['subject']}---")
    # Simulate a LLM.
    joke_map = {
        "lions": "Why don't lions like fast food? Because they can't catch it!",
        "elephants": "Why don't elephants use computers? They're afraid of the mouse!",
        "penguins": (
            "Why donâ€™t penguins like talking to strangers at parties? "
            "Because they find it hard to break the ice."
        ),
    }
    return {"jokes": [joke_map[state["subject"]]]}


# Here we define the logic to map out over the generated subjects
# We will use this as an edge in the graph
def continue_to_jokes(state: OverallState):
    """Conditional edge that sends a task to generate_joke for each subject."""
    print("---CONTINUE TO JOKES---")
    # We will return a list of `Send` objects
    # Each `Send` object consists of the name of a node in the graph
    # as well as the state to send to that node
    return [Send("generate_joke", {"subject": s}) for s in state["subjects"]]


# Here we will judge the best joke
def best_joke(state: OverallState):
    """Selects the best joke from the list of generated jokes."""
    print("---SELECT BEST JOKE---")
    # A simple logic to select the best joke
    # In a real scenario, this could involve a call to another LLM or a more complex heuristic.
    best_joke_text = ""
    if state["jokes"]:
        # Let's say the best joke is the one about penguins for this example
        for joke in state["jokes"]:
            if "penguins" in joke.lower():
                best_joke_text = joke
                break
        if not best_joke_text:
            best_joke_text = state["jokes"][0]  # Default to the first joke if no specific one is found

    return {"best_selected_joke": best_joke_text}


# Construct the graph: here we put everything together to construct our graph
builder = StateGraph(OverallState)
builder.add_node("generate_topics", generate_topics)
builder.add_node("generate_joke", generate_joke)
builder.add_node("best_joke", best_joke)

builder.add_edge(START, "generate_topics")

# This conditional edge is the key to the map-reduce pattern.
# It dynamically creates branches to the "generate_joke" node.
builder.add_conditional_edges(
    "generate_topics",
    continue_to_jokes,
)

# After all parallel joke generation branches are complete, they all proceed to the "best_joke" node.
builder.add_edge("generate_joke", "best_joke")
builder.add_edge("best_joke", END)

graph = builder.compile()


def main():
    """Main function to run the graph and print the results."""
    print("Starting the map-reduce graph execution...")
    initial_state = {"topic": "animals"}
    final_state = graph.invoke(initial_state)

    print("\n---FINAL RESULT---")
    print(f"Topic: {final_state['topic']}")
    print(f"Generated Subjects: {final_state['subjects']}")
    print("Generated Jokes:")
    for joke in final_state["jokes"]:
        print(f"- {joke}")
    print(f"Best Selected Joke: {final_state['best_selected_joke']}")
    print("\nGraph execution finished.")


if __name__ == "__main__":
    main()
