"""
Tool Executor for the Enterprise Knowledge Assistant.

This module provides a tool executor that can be used to execute tools
in the Enterprise Knowledge Assistant, building on the concepts from the
basic tools section of the LangGraph mastery curriculum.
"""

import logging
from typing import Dict, Any, List, Optional, Union

from langchain_core.tools import BaseTool
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from langchain_google_genai import ChatGoogleGenerativeAI
from langgraph.prebuilt import create_react_agent

from src.config import get_config
from src.models.state import AssistantState, ErrorSeverity
from src.tools.search_tool import get_search_tool

logger = logging.getLogger(__name__)
config = get_config()

def get_tools() -> List[BaseTool]:
    """Get the available tools.
    
    Returns:
        List[BaseTool]: The available tools.
    """
    tools = [
        get_search_tool(),
        # Add more tools here as needed
    ]
    
    return tools

def create_tool_using_agent():
    """Create an agent that can use tools.
    
    Returns:
        Any: The agent.
    """
    # Create a chat model
    model = ChatGoogleGenerativeAI(
        model=config.ai_model.model_name,
        temperature=0.5,
        convert_system_message_to_human=True
    )
    
    # Get the tools
    tools = get_tools()
    
    # Create the agent
    agent = create_react_agent(
        model,
        tools,
        prompt="""You are a helpful assistant with access to tools.
Use these tools to answer the user's questions about company information.
Always think step by step about which tool would be most appropriate to use.

When searching for information:
1. Formulate a clear search query
2. Examine the search results carefully
3. Extract the relevant information
4. Provide a comprehensive answer

If the information is not available, acknowledge this limitation and suggest
what additional information might be needed.
""",
        debug=config.debug
    )
    
    return agent

def execute_tools(state: Dict[str, Any]) -> Dict[str, Any]:
    """Execute tools based on the current state.
    
    Args:
        state: The current state.
        
    Returns:
        Dict[str, Any]: The updated state.
    """
    logger.info("Executing tools")
    
    # Convert dict to AssistantState for easier manipulation
    state_obj = AssistantState.model_validate(state)
    query = state_obj.query
    
    try:
        # Create the agent
        agent = create_tool_using_agent()
        
        # Create the messages
        messages = [HumanMessage(content=query)]
        
        # Add context from the state if available
        if state_obj.results.get("query_understanding"):
            analysis = state_obj.results["query_understanding"].get("analysis", "")
            if analysis:
                messages = [
                    SystemMessage(content=f"Use this query analysis to help you: {analysis}"),
                    HumanMessage(content=query)
                ]
        
        # Execute the agent
        logger.debug(f"Executing agent with query: {query}")
        agent_result = agent.invoke({"messages": messages})
        
        # Extract the result
        if "messages" in agent_result:
            response = agent_result["messages"][-1].content
        else:
            response = "No response generated by the agent."
        
        # Update the state
        state_obj.results["tool_execution"] = {
            "response": response,
            "tool_calls": agent_result.get("tool_calls", []),
            "intermediate_steps": agent_result.get("intermediate_steps", [])
        }
        
        # Add the response to the messages
        state_obj.messages.append(AIMessage(content=response))
        
        logger.info("Tool execution completed successfully")
        
    except Exception as e:
        logger.error(f"Error in tool execution: {str(e)}", exc_info=True)
        state_obj.add_error(
            message=f"Failed to execute tools: {str(e)}",
            node="tool_execution",
            severity=ErrorSeverity.ERROR,
            details={"query": query}
        )
    
    # Return the updated state
    return state_obj.model_dump()
